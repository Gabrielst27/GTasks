import { BadRequestException, NotFoundException } from '@nestjs/common';
import { EDbOperators } from 'src/common/enum/db-operators.enum';
import { BaseRepository } from 'src/common/repositories/repository';
import { SearchParams } from 'src/common/repositories/search-params';
import { SearchResult } from 'src/common/repositories/search-result';
import { AppQuery } from 'src/common/utils/app-queries/app-query';
import { PrismaService } from 'src/modules/shared/prisma/prisma.service';
import { TaskEntity } from 'src/domain/tasks/entities/task-entity';
import { TaskPrismaModelMapper } from 'src/modules/tasks/repositories/prisma/task-prisma-model.mapper';
import { ITaskRepository } from 'src/domain/tasks/repositories/task-repository';

export class TaskPrismaRepository
  extends BaseRepository
  implements ITaskRepository
{
  protected searchableFields: string[] = ['projectId', 'title'];
  protected sortableFields: string[] = [
    'title',
    'createdAt',
    'updatedAt',
    'dueDate',
  ];

  constructor(private prismaService: PrismaService) {
    super();
  }

  async findById(id: string): Promise<TaskEntity> {
    const model = await this.prismaService.task.findUnique({
      where: { id },
    });
    if (!model) throw new NotFoundException('Task n√£o encontrada');
    return TaskPrismaModelMapper.toEntity(model);
  }

  async findMany(
    searchParams: SearchParams,
    queries: AppQuery[],
  ): Promise<SearchResult<TaskEntity>> {
    const searchFields = queries.map((query) => query.field);
    super.validateQuery(searchFields, searchParams.sort);
    const haveProjectId = searchFields.includes('projectId');
    if (!haveProjectId) {
      throw new BadRequestException('Task deve estar vinculada a um projeto');
    }

    const skip = searchParams.perPage * searchParams.page;
    const take = searchParams.perPage;

    const filters = await this.prismaService.$extends({
      query: {
        task: {
          count({ model, operation, args, query }) {
            args.where = {
              AND: queries.map((q) => ({
                [q.field]:
                  q.operator === EDbOperators.EQUALS
                    ? q.value
                    : [TaskPrismaModelMapper.operatorToModelEnum(q.operator)],
              })),
            };
            return query(args);
          },
          findMany({ model, operation, args, query }) {
            args.where = {
              AND: queries.map((q) => ({
                [q.field]:
                  q.operator === EDbOperators.EQUALS
                    ? q.value
                    : [TaskPrismaModelMapper.operatorToModelEnum(q.operator)],
              })),
            };
            args.orderBy = { [searchParams.sort]: searchParams.sortDir };
            args.skip = skip;
            args.take = take;
            return query(args);
          },
        },
      },
    });

    const total = await filters.task.count();
    const models = await filters.task.findMany();
    const items = models.map((model) => TaskPrismaModelMapper.toEntity(model));

    return new SearchResult({
      items,
      total,
      page: searchParams.page,
      perPage: searchParams.perPage,
      sort: searchParams.sort,
      sortDir: searchParams.sortDir,
    });
  }

  async create(item: TaskEntity): Promise<TaskEntity> {
    const model = TaskPrismaModelMapper.toModel(item);
    await this.prismaService.task.create({
      data: model,
    });
    return item;
  }

  async update(id: string, item: TaskEntity): Promise<TaskEntity> {
    const model = TaskPrismaModelMapper.toModel(item);
    await this.prismaService.task.update({
      where: { id },
      data: model,
    });
    return item;
  }

  delete(id: string): Promise<TaskEntity> {
    throw new Error('Method not implemented.');
  }
}
